
介绍：
	promise 对象用于异步计算

	一个promise表示一个现在、将来或者永不可能可用的值

	可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果。

	可以在对象之间传递和操作promise,帮助我们处理队列


产生的原因：

	js 为检查表单而生的

	创造js 首要的目标就是操作dom，获取表单的数据

	js 如果没有异步的话，就会产生页面冻结（大忌）

	所以Javascript 包含大量异步操作

异步操作的长常见语法
	
	事件的监听与响应（addEventlistener,jq里的on）

	函数的回调 (通常先调用一个外部的函数，然后传递进去一个回调函数； $.ajax() 和  $(function(){}))

当只有上面的事件和回调时，异步的问题还不是很严重。


node出现后
	
	对异步的依赖进一步加剧：在node前php python等后端的语言已经很成熟，想要有一席之位，则异步的操作显得尤为的重要


node的特点：
	
	*无阻塞高并发，是node 的招牌（为了达到无阻塞高并发，必须依赖于异步）

	以php 为例，一个用户进来要从数据库中取出一百行的数据，PHP就会等待数据库返回结果后，才会去执行下一个命令（意味着下一个命令将被挂起，等待上一个命令执行完。）
	node 就不会，若这个命令耗时，后面还有命令要执行，node就会将这个命令给系统的组件执行，从而去接收下一个命令。
	node里面的很多操作都依赖与系统函数执行的。

异步回调的问题

	异步回调，稍有不慎，很容易踏入----回调地狱（不知道上一个回调什么时候完成）


	例子：一个A函数被调用，里面有一个B的回调函数，函数的执行会产生执行栈，入栈入栈，出栈出栈。 当A执行完成后，其执行栈会被清空，栈就结束啦。A结束后系统会调用回调函数，会有一个新的执行栈来执行回调函数,在A的函数外用try-catch捕获回调产生的错误时捕获不到的。

	function findLargest(dir , callback){
		fs.readdir(dir,function(err,files){//里面有一个匿名回调函数 当读取失败时，将err返回出去，因为和主函数不在同一个调用栈，有try --catch捕获不到
				if(err){
					return callback(err);//用传进来的callback将错误的信息返回到外部去
				}
			})
	}

	问题一：异步回调的过程中无法正常的使用try--catch这样的错误处理机制来处理错误


	问题二：在异步情况下我们没有办法去判断某个操作什么时候完成，我们就得得在高级作用域上定义一些变量供内层函数（回调函数)去使用,这样的情况就有可能导致有些函数可以修改和访问这些变量的值，从而导致结果出错。

总结：回调有四个问题
	 
	 *嵌套层次容易写的很深，难以维护(容易陷入回调地狱，使代码很难维护)

	 *无法正常的使用return 和 throw

	 *无法正常的检索堆栈信息 （因为每一次的回调都是在系统层面上的一个新的堆栈）

	 *多个回调之间很难建立联系（一个回调一旦启动，我们就再也没有办法对它进行操作）




