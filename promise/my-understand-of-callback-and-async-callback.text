callback 
	
	函数可以当参数传到另一个函数，在另一个函数里面执行

	回调函数分为：匿名回调 和 有名回调 

		function callback(){...}
		function fn(callback){..}

		function fn(function(){})

	真正的回调函数就是有来解决异步的

	异步处理的时间不确定，不知道什么时候执行结束，回调函数就起到大作用。当异步处理完后，回调函数会执行，可以操作其执行过后的结果	



****************
	异步处理时，回调函数的错误不能有try -- catch 在外层捕获, 这么理解，当异步有回调函数时，会有一个线程来监听异步处理程序，当处理完时就调用回调函数，处理完就相当于出栈，然后回调函数在入栈。相当于回调函数的执行栈和原本的异步处理程序的执行栈不同一个，（也可以这么理解 ————》 try --catch之所以捕获不到，是以为我们try 的是主函数，当主函数执行完才会去调用回调函数,这时主函数执行完，try也就try完拉，还没等回调执行抛出错误，catch就执行啦，所以catch不到）用try- catch是捕获不到的。

***************
	一个进程一个调用栈 ，上面的主函数与回调函数不在同一个调用栈（其实是在同一个调用栈，但是环境不同了，也可以理解成不同的调用栈，但是一个进程就只有一个调用栈）






	其实所谓的js单线程是指用户线程（主线程）是单线程，而另外还有一个或多个线程处理异步代码的执行。


	很多文章里面在讲解的时候同步异步阻塞非阻塞混为一团，新手很难理解，最容易产生的误解就是同步=阻塞，异步=非阻塞。其实阻塞非阻塞跟同步异步没有任何关系。简单讲，阻塞就是一个api或者函数运行时间过长，而独占cpu导致其他代码不能运行，那么多长时间算阻塞呢？相信这只是一个相对的概念，只要明显影响到程序的性能和用户体验，就算阻塞吧。那跟同步异步是什么关系呢？阻塞的代码如果同步执行就会阻塞到自己后面代码的运行，所以自然而然的就想到异步来执行阻塞的代码，然而异步真能解决阻塞问题吗
